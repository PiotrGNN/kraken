"""
Strategy executor for the DeepAgent Kraken trading bot.

This module is responsible for executing trades based on signals
generated by the trading strategy.
"""
import logging
import time
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import pandas as pd
import threading

from app.core.order_router import OrderRouter, OrderSide, OrderType, PositionSide
from app.strategies.trend_rsi import TrendRSIStrategy, SignalType

logger = logging.getLogger(__name__)

class StrategyExecutor:
    """
    Strategy executor for the DeepAgent Kraken trading bot.
    
    This class is responsible for:
    1. Running the strategy at regular intervals
    2. Executing trades based on strategy signals
    3. Managing open positions and orders
    4. Handling errors and failover scenarios
    """
    
    def __init__(self, order_router: OrderRouter, strategy_config: Dict):
        """
        Initialize the strategy executor.
        
        Args:
            order_router: OrderRouter instance for exchange interactions
            strategy_config: Strategy configuration
        """
        self.order_router = order_router
        self.config = strategy_config
        self.symbol = strategy_config['symbol']
        
        # Create strategy instance
        self.strategy = TrendRSIStrategy(order_router, strategy_config)
        
        # Execution parameters
        self.execution_interval = self._parse_interval_to_seconds(strategy_config.get('interval', '1h'))
        self.max_retries = strategy_config.get('max_retries', 3)
        self.retry_delay = strategy_config.get('retry_delay', 5)  # seconds
        
        # State variables
        self.is_running = False
        self.last_execution_time = None
        self.execution_thread = None
        self.active_orders = {}
        
        logger.info(f"Initialized StrategyExecutor for {self.symbol}")
    
    def _parse_interval_to_seconds(self, interval: str) -> int:
        """
        Parse interval string to seconds.
        
        Args:
            interval: Interval string (e.g., '1m', '5m', '1h', '1d')
            
        Returns:
            Interval in seconds
        """
        unit = interval[-1]
        value = int(interval[:-1])
        
        if unit == 'm':
            return value * 60
        elif unit == 'h':
            return value * 60 * 60
        elif unit == 'd':
            return value * 24 * 60 * 60
        else:
            logger.warning(f"Unknown interval unit: {unit}, defaulting to 1 hour")
            return 60 * 60
    
    def start(self) -> None:
        """Start the strategy executor."""
        if self.is_running:
            logger.warning("Strategy executor is already running")
            return
        
        self.is_running = True
        self.execution_thread = threading.Thread(target=self._execution_loop)
        self.execution_thread.daemon = True
        self.execution_thread.start()
        
        logger.info(f"Started strategy executor for {self.symbol}")
    
    def stop(self) -> None:
        """Stop the strategy executor."""
        if not self.is_running:
            logger.warning("Strategy executor is not running")
            return
        
        self.is_running = False
        if self.execution_thread:
            self.execution_thread.join(timeout=10)
        
        logger.info(f"Stopped strategy executor for {self.symbol}")
    
    def _execution_loop(self) -> None:
        """Main execution loop."""
        while self.is_running:
            try:
                # Check if it's time to execute
                current_time = datetime.now()
                if (not self.last_execution_time or 
                    (current_time - self.last_execution_time).total_seconds() >= self.execution_interval):
                    
                    # Execute strategy
                    self.execute_strategy()
                    
                    # Update last execution time
                    self.last_execution_time = current_time
                
                # Sleep for a short time
                time.sleep(1)
                
            except Exception as e:
                logger.error(f"Error in execution loop: {e}")
                time.sleep(10)  # Sleep longer on error
    
    def execute_strategy(self) -> Dict:
        """
        Execute the strategy once.
        
        Returns:
            Dictionary with execution results
        """
        try:
            # Run strategy to get signal
            strategy_result = self.strategy.run()
            signal = strategy_result['signal']
            
            # Get account information
            account_info = self.order_router.get_account_info()
            equity = float(account_info.get('equity', account_info.get('totalEquity', 0)))
            
            # Get current position
            position = self.order_router.get_position(self.symbol)
            current_position_size = float(position.get('size', 0))
            current_position_side = position.get('side', None)
            
            # Execute signal
            execution_result = None
            
            if signal == SignalType.LONG:
                # Check if already in LONG position
                if current_position_side == 'Buy' and current_position_size > 0:
                    logger.info(f"Already in LONG position for {self.symbol}, skipping")
                else:
                    # Close any existing SHORT position
                    if current_position_side == 'Sell' and current_position_size > 0:
                        self._close_position(PositionSide.SHORT)
                    
                    # Enter LONG position
                    execution_result = self._enter_position(SignalType.LONG, equity, strategy_result['indicators']['atr'])
            
            elif signal == SignalType.SHORT:
                # Check if already in SHORT position
                if current_position_side == 'Sell' and current_position_size > 0:
                    logger.info(f"Already in SHORT position for {self.symbol}, skipping")
                else:
                    # Close any existing LONG position
                    if current_position_side == 'Buy' and current_position_size > 0:
                        self._close_position(PositionSide.LONG)
                    
                    # Enter SHORT position
                    execution_result = self._enter_position(SignalType.SHORT, equity, strategy_result['indicators']['atr'])
            
            elif signal == SignalType.CLOSE_LONG:
                # Close LONG position
                if current_position_side == 'Buy' and current_position_size > 0:
                    execution_result = self._close_position(PositionSide.LONG)
            
            elif signal == SignalType.CLOSE_SHORT:
                # Close SHORT position
                if current_position_side == 'Sell' and current_position_size > 0:
                    execution_result = self._close_position(PositionSide.SHORT)
            
            # Return execution results
            return {
                'timestamp': pd.Timestamp.now(),
                'symbol': self.symbol,
                'signal': signal,
                'execution_result': execution_result,
                'equity': equity,
                'current_position': {
                    'side': current_position_side,
                    'size': current_position_size
                }
            }
            
        except Exception as e:
            logger.error(f"Error executing strategy: {e}")
            return {
                'timestamp': pd.Timestamp.now(),
                'symbol': self.symbol,
                'error': str(e)
            }
    
    def _enter_position(self, signal: SignalType, equity: float, atr: float) -> Dict:
        """
        Enter a new position.
        
        Args:
            signal: Signal type (LONG or SHORT)
            equity: Account equity
            atr: Current ATR value
            
        Returns:
            Dictionary with order information
        """
        try:
            # Calculate position size
            position_size = self.strategy.calculate_position_size(equity, atr)
            
            if position_size <= 0:
                logger.warning(f"Invalid position size: {position_size}, skipping")
                return {'error': 'Invalid position size'}
            
            # Get current market price
            ticker = self.order_router.current_exchange.get_ticker(self.symbol)
            current_price = float(ticker['last'])
            
            # Determine order parameters based on signal
            if signal == SignalType.LONG:
                order_side = OrderSide.BUY
                position_side = PositionSide.LONG
                stop_loss_price = self.strategy.calculate_stop_loss(current_price, atr, signal)
            else:  # SHORT
                order_side = OrderSide.SELL
                position_side = PositionSide.SHORT
                stop_loss_price = self.strategy.calculate_stop_loss(current_price, atr, signal)
            
            # Place market order
            for retry in range(self.max_retries):
                try:
                    order = self.order_router.create_order(
                        symbol=self.symbol,
                        side=order_side,
                        order_type=OrderType.MARKET,
                        quantity=position_size,
                        position_side=position_side
                    )
                    
                    # Store order information
                    self.active_orders[order['orderId']] = order
                    
                    # Update strategy state
                    self.strategy.current_position = signal
                    self.strategy.entry_price = current_price
                    self.strategy.position_size = position_size
                    
                    logger.info(f"Entered {signal} position for {self.symbol} at {current_price:.2f} with size {position_size:.6f}")
                    
                    # Place stop loss order
                    stop_loss_order = self._place_stop_loss(signal, position_size, stop_loss_price)
                    
                    if stop_loss_order:
                        self.strategy.stop_loss_price = stop_loss_price
                        self.strategy.stop_loss_order_id = stop_loss_order['orderId']
                    
                    return {
                        'entry_order': order,
                        'stop_loss_order': stop_loss_order,
                        'position': {
                            'side': signal,
                            'size': position_size,
                            'entry_price': current_price,
                            'stop_loss_price': stop_loss_price
                        }
                    }
                    
                except Exception as e:
                    logger.error(f"Error entering position (attempt {retry+1}/{self.max_retries}): {e}")
                    if retry < self.max_retries - 1:
                        time.sleep(self.retry_delay)
            
            return {'error': f"Failed to enter position after {self.max_retries} attempts"}
            
        except Exception as e:
            logger.error(f"Error entering position: {e}")
            return {'error': str(e)}
    
    def _place_stop_loss(self, signal: SignalType, position_size: float, stop_price: float) -> Optional[Dict]:
        """
        Place a stop loss order.
        
        Args:
            signal: Signal type (LONG or SHORT)
            position_size: Position size
            stop_price: Stop loss price
            
        Returns:
            Dictionary with order information or None if failed
        """
        try:
            # Determine order parameters based on signal
            if signal == SignalType.LONG:
                order_side = OrderSide.SELL
                position_side = PositionSide.LONG
            else:  # SHORT
                order_side = OrderSide.BUY
                position_side = PositionSide.SHORT
            
            # Place stop loss order
            for retry in range(self.max_retries):
                try:
                    stop_order = self.order_router.create_order(
                        symbol=self.symbol,
                        side=order_side,
                        order_type=OrderType.STOP_MARKET,
                        quantity=position_size,
                        price=stop_price,
                        position_side=position_side,
                        reduce_only=True
                    )
                    
                    # Store order information
                    self.active_orders[stop_order['orderId']] = stop_order
                    
                    logger.info(f"Placed stop loss order for {self.symbol} at {stop_price:.2f}")
                    
                    return stop_order
                    
                except Exception as e:
                    logger.error(f"Error placing stop loss (attempt {retry+1}/{self.max_retries}): {e}")
                    if retry < self.max_retries - 1:
                        time.sleep(self.retry_delay)
            
            logger.error(f"Failed to place stop loss after {self.max_retries} attempts")
            return None
            
        except Exception as e:
            logger.error(f"Error placing stop loss: {e}")
            return None
    
    def _close_position(self, position_side: PositionSide) -> Dict:
        """
        Close an existing position.
        
        Args:
            position_side: Position side (LONG or SHORT)
            
        Returns:
            Dictionary with order information
        """
        try:
            # Get current position
            position = self.order_router.get_position(self.symbol)
            position_size = float(position.get('size', 0))
            
            if position_size <= 0:
                logger.warning(f"No position to close for {self.symbol}")
                return {'error': 'No position to close'}
            
            # Determine order parameters based on position side
            if position_side == PositionSide.LONG:
                order_side = OrderSide.SELL
            else:  # SHORT
                order_side = OrderSide.BUY
            
            # Place market order to close position
            for retry in range(self.max_retries):
                try:
                    order = self.order_router.create_order(
                        symbol=self.symbol,
                        side=order_side,
                        order_type=OrderType.MARKET,
                        quantity=position_size,
                        position_side=position_side,
                        reduce_only=True
                    )
                    
                    # Store order information
                    self.active_orders[order['orderId']] = order
                    
                    # Cancel any active stop loss orders
                    self._cancel_stop_orders()
                    
                    # Update strategy state
                    self.strategy.current_position = None
                    self.strategy.entry_price = None
                    self.strategy.stop_loss_price = None
                    self.strategy.trailing_stop_price = None
                    self.strategy.position_size = None
                    
                    logger.info(f"Closed {position_side} position for {self.symbol} with size {position_size:.6f}")
                    
                    return {
                        'close_order': order,
                        'position_side': position_side,
                        'position_size': position_size
                    }
                    
                except Exception as e:
                    logger.error(f"Error closing position (attempt {retry+1}/{self.max_retries}): {e}")
                    if retry < self.max_retries - 1:
                        time.sleep(self.retry_delay)
            
            return {'error': f"Failed to close position after {self.max_retries} attempts"}
            
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return {'error': str(e)}
    
    def _cancel_stop_orders(self) -> None:
        """Cancel all active stop orders."""
        try:
            # Get open orders
            open_orders = self.order_router.current_exchange.get_open_orders(self.symbol)
            
            # Cancel stop orders
            for order in open_orders:
                if order['type'] in ['STOP', 'STOP_MARKET', 'STOP_LOSS', 'STOP_LOSS_LIMIT']:
                    try:
                        self.order_router.cancel_order(order['orderId'], self.symbol)
                        logger.info(f"Cancelled stop order {order['orderId']} for {self.symbol}")
                    except Exception as e:
                        logger.error(f"Error cancelling stop order {order['orderId']}: {e}")
            
        except Exception as e:
            logger.error(f"Error cancelling stop orders: {e}")
    
    def get_status(self) -> Dict:
        """
        Get current status of the strategy executor.
        
        Returns:
            Dictionary with status information
        """
        try:
            # Get current position
            position = self.order_router.get_position(self.symbol)
            
            # Get open orders
            open_orders = self.order_router.current_exchange.get_open_orders(self.symbol)
            
            return {
                'timestamp': pd.Timestamp.now(),
                'symbol': self.symbol,
                'is_running': self.is_running,
                'last_execution_time': self.last_execution_time,
                'current_position': position,
                'open_orders': open_orders,
                'strategy_state': {
                    'current_position': self.strategy.current_position,
                    'entry_price': self.strategy.entry_price,
                    'stop_loss_price': self.strategy.stop_loss_price,
                    'trailing_stop_price': self.strategy.trailing_stop_price,
                    'position_size': self.strategy.position_size
                }
            }
            
        except Exception as e:
            logger.error(f"Error getting status: {e}")
            return {
                'timestamp': pd.Timestamp.now(),
                'symbol': self.symbol,
                'error': str(e)
            }
